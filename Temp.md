<!-- Binary Search Tree (BST) -->

## 10. Binary Search Tree (BST)

1. **Basic Binary Search Tree Creation:**

   - **Problem:** Write a program to create a binary search tree with the following values: `50, 30, 20, 40, 70, 60, 80`. Display the structure of the tree.

2. **Insert a Node in a Binary Search Tree:**

   - **Problem:** Write a program to insert a node into a binary search tree. Insert the value `65` into the binary search tree created in the previous problem.

3. **Search for a Node in a Binary Search Tree:**

   - **Problem:** Write a function to search for a node with a specific value in a binary search tree. Use the tree created in the first problem to search for the value `40`.

4. **Delete a Node from a Binary Search Tree:**

   - **Problem:** Write a function to delete a node from a binary search tree. Use the tree from the previous problem and delete the node with the value `70`.

5. **Find the Minimum and Maximum in a Binary Search Tree:**

   - **Problem:** Write functions to find the minimum and maximum values in a binary search tree. Use the BST from the previous problems to find both.

6. **Find the Height of a Binary Search Tree:**

   - **Problem:** Write a function to find the height of a binary search tree. Use the BST created earlier and determine its height.

7. **Inorder Successor in a Binary Search Tree:**

   - **Problem:** Write a function to find the inorder successor of a given node in a binary search tree. Use the tree created earlier and find the inorder successor of node `60`.

8. **Check if a Tree is a Binary Search Tree:**

   - **Problem:** Write a function to check if a given binary tree is a binary search tree. Create a sample tree and test this function.

9. **Find the Lowest Common Ancestor (LCA) in a Binary Search Tree:**

   - **Problem:** Write a function to find the lowest common ancestor of two nodes in a binary search tree. Use the tree from earlier problems to find the LCA of nodes `20` and `40`.

10. **Find the Kth Smallest Element in a Binary Search Tree:**

    - **Problem:** Write a function to find the k-th smallest element in a binary search tree. Use the tree created earlier and find the 3rd smallest element.

11. **Check if a Binary Search Tree is Balanced:**

    - **Problem:** Write a function to check if a binary search tree is balanced. A balanced tree is one where the height difference between left and right subtrees is at most `1`. Use the tree from the previous problems.

12. **Convert a Binary Search Tree to a Doubly Linked List:**

    - **Problem:** Write a function to convert a binary search tree into a doubly linked list using in-order traversal. Display the resulting linked list.

13. **Find the Closest Value to a Given Target in a Binary Search Tree:**

    - **Problem:** Write a function to find the value in a binary search tree that is closest to a given target value. Use the tree created earlier and find the closest value to `55`.

14. **Find the Mode (Most Frequent Element) in a Binary Search Tree:**

    - **Problem:** Write a function to find the mode (the value that appears most frequently) in a binary search tree. Create a BST with duplicate values and find the mode.

15. **Inorder Predecessor in a Binary Search Tree:**

    - **Problem:** Write a function to find the inorder predecessor of a given node in a binary search tree. Use the tree created earlier and find the inorder predecessor of node `40`.

16. **Merge Two Binary Search Trees:**

    - **Problem:** Write a program to merge two binary search trees into one binary search tree. Create two sample BSTs and merge them.

17. **Print All Elements in a Given Range in a Binary Search Tree:**

    - **Problem:** Write a function to print all elements in a binary search tree that lie within a given range `[low, high]`. Use the tree created earlier to print elements within the range `[30, 70]`.

18. **Find the Floor and Ceiling of a Value in a Binary Search Tree:**

    - **Problem:** Write a function to find the floor (largest value smaller than or equal to the target) and ceiling (smallest value larger than or equal to the target) of a given value in a binary search tree. Use the tree created earlier to find the floor and ceiling of `65`.

19. **Check if Two Binary Search Trees are Identical:**

    - **Problem:** Write a function to check if two binary search trees are identical in terms of structure and node values. Create two identical trees and one different tree to test your function.

20. **Convert a Sorted Array to a Binary Search Tree:**

    - **Problem:** Write a function to convert a sorted array into a balanced binary search tree. Use the sorted array `[10, 20, 30, 40, 50, 60, 70, 80]` and create a balanced BST.

21. **Find the Diameter of a Binary Search Tree:**

    - **Problem:** Write a function to calculate the diameter (the longest path between two leaf nodes) of a binary search tree. Use the tree from earlier problems and calculate its diameter.

22. **Find All Nodes at a Given Distance from a Node in a Binary Search Tree:**

    - **Problem:** Write a function to find all nodes that are at a distance `k` from a given node in a binary search tree. Use the tree created earlier and find nodes at distance `2` from node `30`.

23. **Print Nodes at K Distance from the Root in a Binary Search Tree:**

    - **Problem:** Write a function to print all nodes at a distance `k` from the root of a binary search tree. Use the tree created earlier and print nodes at distance `2`.

24. **Serialize and Deserialize a Binary Search Tree:**

    - **Problem:** Write functions to serialize a binary search tree (convert it into a string) and deserialize the string back into the original tree. Test both functions to ensure they are working correctly.

25. **Build a BST to hold only unique elements (Set):**

    - **Problem:** Write a program to create Binary Search Tree(BST) to hold unique elements like Set.

<!-- Self-Balancing Binary Search Tree (SB-BST) -->

## 11. Self-Balancing Binary Search Tree (AVL/Red-Black Trees)

1. **Create an AVL Tree:**

   - **Problem:** Write a program to create an AVL tree by inserting the following values: `30, 20, 40, 10, 25, 35, 50`. Ensure that the tree remains balanced after each insertion and display the final tree.

2. **Insert a Node in an AVL Tree:**

   - **Problem:** Write a function to insert a node into an AVL tree. Insert the value `15` into the AVL tree created in the previous problem, and ensure that the tree remains balanced.

3. **Delete a Node from an AVL Tree:**

   - **Problem:** Write a function to delete a node from an AVL tree while maintaining the tree's balance. Use the AVL tree from the previous problems and delete the node with the value `40`.

4. **Check the Balance Factor of Nodes in an AVL Tree:**

   - **Problem:** Write a function to calculate and print the balance factor (difference between the heights of left and right subtrees) of every node in an AVL tree. Use the AVL tree created earlier.

5. **Right and Left Rotations in an AVL Tree:**

   - **Problem:** Write functions to perform right and left rotations on nodes in an AVL tree. Use these functions to rotate the AVL tree created earlier at the root node.

6. **Rebalance an AVL Tree:**

   - **Problem:** Write a function to rebalance an AVL tree after an insertion or deletion. Test this function by inserting `45` and deleting `10` from the AVL tree created earlier.

7. **Create a Red-Black Tree:**

   - **Problem:** Write a program to create a Red-Black Tree by inserting the following values: `50, 30, 70, 20, 40, 60, 80`. Ensure that the Red-Black properties (coloring, balancing, etc.) are maintained after every insertion.

8. **Insert a Node in a Red-Black Tree:**

   - **Problem:** Write a function to insert a node into a Red-Black Tree while maintaining the Red-Black Tree properties. Insert the value `90` into the Red-Black Tree created in the previous problem.

9. **Delete a Node from a Red-Black Tree:**

   - **Problem:** Write a function to delete a node from a Red-Black Tree while maintaining its properties. Use the Red-Black Tree from the previous problems and delete the node with the value `30`.

10. **Check Red-Black Tree Properties:**

    - **Problem:** Write a function to verify that a tree satisfies all Red-Black Tree properties (every node is either red or black, the root is black, red nodes have black children, etc.). Test this function with the Red-Black Tree created earlier.

11. **Right and Left Rotations in a Red-Black Tree:**

    - **Problem:** Write functions to perform right and left rotations on nodes in a Red-Black Tree. Use these functions to rotate the Red-Black Tree created earlier at the root node.

12. **Rebalance a Red-Black Tree:**

    - **Problem:** Write a function to rebalance a Red-Black Tree after an insertion or deletion. Test this function by inserting `65` and deleting `50` from the Red-Black Tree created earlier.

13. **Find the Height of an AVL/Red-Black Tree:**

    - **Problem:** Write a function to calculate the height of an AVL tree and a Red-Black tree. Compare the heights of both trees created earlier.

14. **Find the Minimum and Maximum in an AVL/Red-Black Tree:**

    - **Problem:** Write functions to find the minimum and maximum values in both an AVL tree and a Red-Black Tree. Use the trees created earlier to find both values.

15. **Find the Kth Smallest Element in an AVL/Red-Black Tree:**

    - **Problem:** Write a function to find the k-th smallest element in both an AVL tree and a Red-Black Tree. Use the trees created earlier and find the 3rd smallest element in each.

16. **Find the Lowest Common Ancestor (LCA) in an AVL/Red-Black Tree:**

    - **Problem:** Write a function to find the lowest common ancestor of two nodes in an AVL tree and a Red-Black Tree. Use the trees created earlier to find the LCA of nodes `20` and `40`.

17. **Find the Inorder Successor and Predecessor in an AVL/Red-Black Tree:**

    - **Problem:** Write functions to find the inorder successor and inorder predecessor of a given node in both an AVL tree and a Red-Black Tree. Use the trees created earlier to find the inorder successor and predecessor of node `40`.

18. **Check if Two AVL/Red-Black Trees are Identical:**

    - **Problem:** Write a function to check if two AVL trees or two Red-Black Trees are identical in terms of structure and node values. Create two identical trees and one different tree to test your function.

19. **Convert a Sorted Array to an AVL/Red-Black Tree:**

    - **Problem:** Write a function to convert a sorted array into an AVL tree and a Red-Black Tree. Use the sorted array `[10, 20, 30, 40, 50, 60, 70, 80]` to create both trees.

20. **Print All Elements in a Given Range in an AVL/Red-Black Tree:**

    - **Problem:** Write a function to print all elements in both an AVL tree and a Red-Black Tree that lie within a given range `[low, high]`. Use the trees created earlier to print elements within the range `[30, 70]`.

21. **Find the Floor and Ceiling of a Value in an AVL/Red-Black Tree:**

    - **Problem:** Write a function to find the floor (largest value smaller than or equal to the target) and ceiling (smallest value larger than or equal to the target) of a given value in both an AVL tree and a Red-Black Tree. Use the trees created earlier to find the floor and ceiling of `65`.

22. **Print Nodes at K Distance from the Root in an AVL/Red-Black Tree:**

    - **Problem:** Write a function to print all nodes at a distance `k` from the root in both an AVL tree and a Red-Black Tree. Use the trees created earlier and print nodes at distance `2`.

23. **Serialize and Deserialize an AVL/Red-Black Tree:**

    - **Problem:** Write functions to serialize an AVL tree and a Red-Black Tree (convert them into a string) and deserialize the string back into the original trees. Test both functions to ensure they are working correctly.

24. **Find the Diameter of an AVL/Red-Black Tree:**

    - **Problem:** Write a function to calculate the diameter (the longest path between two leaf nodes) of both an AVL tree and a Red-Black Tree. Use the trees from earlier problems and calculate their diameters.

25. **Check if an AVL/Red-Black Tree is Balanced:**

    - **Problem:** Write a function to check if a given AVL tree or Red-Black Tree is balanced. The AVL tree should satisfy the balance factor property, and the Red-Black Tree should satisfy its balancing rules. Use the trees created earlier to test this function.

<!-- Complete Binary Tree -->

## 12. Complete Binary Tree

1. **Basic Complete Binary Tree Creation:**

   - **Problem:** Write a program to create a complete binary tree with the following values: `10, 20, 30, 40, 50, 60, 70`. Display the structure of the complete binary tree.

2. **Insert a Node in a Complete Binary Tree:**

   - **Problem:** Write a function to insert a new node in a complete binary tree at the first available position (level order insertion). Insert the value `80` into the complete binary tree created in the previous problem.

3. **Level Order Traversal of a Complete Binary Tree:**

   - **Problem:** Write a program to perform level order traversal of a complete binary tree. Use a queue to traverse and print the nodes level by level.

4. **Find the Height of a Complete Binary Tree:**

   - **Problem:** Write a function to calculate the height of a complete binary tree. Use the tree created in the previous problems and determine its height.

5. **Find the Number of Nodes in a Complete Binary Tree:**

   - **Problem:** Write a function to count the total number of nodes in a complete binary tree. Use the tree from the previous problems and print the result.

6. **Check if a Tree is Complete:**

   - **Problem:** Write a function to check if a given binary tree is a complete binary tree. Test this function with both complete and incomplete trees.

7. **Find the Last Node in a Complete Binary Tree:**

   - **Problem:** Write a function to find the last node in a complete binary tree (the rightmost node at the deepest level). Use the tree created earlier to find the last node.

8. **Delete the Last Node in a Complete Binary Tree:**

   - **Problem:** Write a function to delete the last node in a complete binary tree. Delete the last node from the tree created in the previous problem.

9. **Inorder Traversal of a Complete Binary Tree:**

   - **Problem:** Write a program to perform inorder traversal of a complete binary tree. Use the tree created earlier and print the nodes in inorder.

10. **Preorder Traversal of a Complete Binary Tree:**

    - **Problem:** Write a program to perform preorder traversal of a complete binary tree. Use the tree created earlier and print the nodes in preorder.

11. **Postorder Traversal of a Complete Binary Tree:**

    - **Problem:** Write a program to perform postorder traversal of a complete binary tree. Use the tree created earlier and print the nodes in postorder.

12. **Check if a Complete Binary Tree is a Full Binary Tree:**

    - **Problem:** Write a function to check if a complete binary tree is also a full binary tree. A full binary tree is a tree where every node has either `0` or `2` children.

13. **Find the Depth of a Complete Binary Tree:**

    - **Problem:** Write a function to calculate the depth of a complete binary tree. Use the tree created earlier to find its depth.

14. **Print Nodes at K Distance from the Root in a Complete Binary Tree:**

    - **Problem:** Write a function to print all nodes at a distance `k` from the root of a complete binary tree. Use the tree created earlier and print nodes at distance `2`.

15. **Find the Maximum Element in a Complete Binary Tree:**

    - **Problem:** Write a function to find the maximum element in a complete binary tree. Use the tree from the previous problems and determine the maximum element.

16. **Find the Minimum Element in a Complete Binary Tree:**

    - **Problem:** Write a function to find the minimum element in a complete binary tree. Use the tree from the previous problems and determine the minimum element.

17. **Find the Leaf Nodes in a Complete Binary Tree:**

    - **Problem:** Write a function to find and print all the leaf nodes in a complete binary tree. Use the tree created earlier to find its leaf nodes.

18. **Find the Diameter of a Complete Binary Tree:**

    - **Problem:** Write a function to determine the diameter of a complete binary tree (the longest path between two leaf nodes). Use the tree from the previous problems and calculate its diameter.

19. **Print All Paths from Root to Leaf in a Complete Binary Tree:**

    - **Problem:** Write a function to print all the paths from the root node to each leaf node in a complete binary tree. Use the tree created earlier to list all such paths.

20. **Check if Two Complete Binary Trees are Identical:**

    - **Problem:** Write a function to check if two complete binary trees are identical in terms of structure and node values. Create two identical trees and one different tree to test your function.

21. **Serialize and Deserialize a Complete Binary Tree:**

    - **Problem:** Write functions to serialize a complete binary tree (convert it into a string) and deserialize the string back into the original tree. Test both functions to ensure they are working correctly.

22. **Convert a Complete Binary Tree to a Doubly Linked List:**

    - **Problem:** Write a function to convert a complete binary tree into a doubly linked list using level order traversal. Display the resulting doubly linked list.

23. **Flatten a Complete Binary Tree to a Linked List:**

    - **Problem:** Write a function to flatten a complete binary tree into a linked list in-place following level order traversal. Use the tree from the previous problems and display the linked list.

24. **Check if a Complete Binary Tree is a Perfect Binary Tree:**

    - **Problem:** Write a function to check if a complete binary tree is also a perfect binary tree. A perfect binary tree is one where all levels are completely filled.

25. **Find the Lowest Common Ancestor (LCA) in a Complete Binary Tree:**

    - **Problem:** Write a function to find the lowest common ancestor (LCA) of two nodes in a complete binary tree. Use the tree created earlier to find the LCA of two nodes.

<!-- Heap -->

## 13. Heap

### Max-Heap Problems:

1. **Basic Max-Heap Creation:**

   - **Problem:** Write a program to create a max-heap from the following values: `10, 20, 30, 40, 50, 60, 70`. Display the structure of the heap.

2. **Insert a Node into a Max-Heap:**

   - **Problem:** Write a function to insert a new node into a max-heap. Insert the value `80` into the max-heap created earlier and ensure that the heap property is maintained.

3. **Delete the Maximum Element from a Max-Heap:**

   - **Problem:** Write a function to delete the maximum element (the root) from a max-heap. Delete the root from the max-heap created earlier and maintain the heap property.

4. **Heapify an Array into a Max-Heap:**

   - **Problem:** Write a function to convert an unsorted array into a max-heap using the heapify process. Use the array `[5, 15, 10, 20, 25, 30, 35]` to create the max-heap.

5. **Find the Maximum Element in a Max-Heap:**

   - **Problem:** Write a function to find and return the maximum element in a max-heap. Use the heap created earlier to find the maximum element.

6. **Extract the Maximum Element from a Max-Heap:**

   - **Problem:** Write a function to extract (remove and return) the maximum element from a max-heap. Ensure that the heap property is maintained after the extraction.

7. **Find the Kth Smallest Element using a Max-Heap:**

   - **Problem:** Write a function to find the k-th smallest element in an array using a max-heap. Use the array `[5, 15, 10, 20, 25, 30, 35]` and find the 2nd smallest element.

8. **Check if a Given Array Represents a Max-Heap:**

   - **Problem:** Write a function to check if a given array represents a valid max-heap. Use the array `[70, 50, 60, 40, 30, 10, 20]` and check if it represents a valid max-heap.

9. **Merge Two Max-Heaps:**

   - **Problem:** Write a function to merge two max-heaps into a single max-heap. Use the max-heaps `[50, 20, 30]` and `[70, 10, 40]` and merge them into one max-heap.

10. **Convert a Max-Heap to a Min-Heap:**

    - **Problem:** Write a function to convert a max-heap into a min-heap. Use the max-heap created earlier and convert it to a min-heap.

11. **Implement Heapsort using a Max-Heap:**

    - **Problem:** Write a program to implement the heapsort algorithm using a max-heap. Use the array `[10, 20, 30, 40, 50, 60, 70]` and sort it in descending order using heapsort.

12. **Find the Height of a Max-Heap:**

    - **Problem:** Write a function to calculate the height of a max-heap. Use the max-heap created earlier and determine its height.

---

### Min-Heap Problems:

1. **Basic Min-Heap Creation:**

- **Problem:** Write a program to create a min-heap from the following values: `10, 20, 30, 40, 50, 60, 70`. Display the structure of the heap.

2. **Insert a Node into a Min-Heap:**

- **Problem:** Write a function to insert a new node into a min-heap. Insert the value `5` into the min-heap created earlier and ensure that the heap property is maintained.

3. **Delete the Minimum Element from a Min-Heap:**

- **Problem:** Write a function to delete the minimum element (the root) from a min-heap. Delete the root from the min-heap created earlier and maintain the heap property.

4. **Heapify an Array into a Min-Heap:**

- **Problem:** Write a function to convert an unsorted array into a min-heap using the heapify process. Use the array `[50, 10, 20, 60, 30, 15]` to create the min-heap.

5. **Find the Minimum Element in a Min-Heap:**

- **Problem:** Write a function to find and return the minimum element in a min-heap. Use the heap created earlier to find the minimum element.

6. **Extract the Minimum Element from a Min-Heap:**

- **Problem:** Write a function to extract (remove and return) the minimum element from a min-heap. Ensure that the heap property is maintained after the extraction.

7. **Find the Kth Largest Element using a Min-Heap:**

- **Problem:** Write a function to find the k-th largest element in an array using a min-heap. Use the array `[50, 20, 30, 60, 70, 10]` and find the 3rd largest element.

8. **Check if a Given Array Represents a Min-Heap:**

- **Problem:** Write a function to check if a given array represents a valid min-heap. Use the array `[10, 15, 20, 40, 50, 60, 70]` and check if it represents a valid min-heap.

9. **Merge Two Min-Heaps:**

- **Problem:** Write a function to merge two min-heaps into a single min-heap. Use the min-heaps `[10, 30, 50]` and `[5, 20, 60]` and merge them into one min-heap.

10. **Convert a Min-Heap to a Max-Heap:**

    - **Problem:** Write a function to convert a min-heap into a max-heap. Use the min-heap created earlier and convert it to a max-heap.

11. **Implement Heapsort using a Min-Heap:**

    - **Problem:** Write a program to implement the heapsort algorithm using a min-heap. Use the array `[70, 50, 60, 40, 30, 20, 10]` and sort it in ascending order using heapsort.

12. **Find the Height of a Min-Heap:**

    - **Problem:** Write a function to calculate the height of a min-heap. Use the min-heap created earlier and determine its height.

---

### Additional Heap Problems:

1. **Print All Elements in a Given Range in a Min-Heap:**

   - **Problem:** Write a function to print all elements in a min-heap that lie within a given range `[low, high]`. Use the min-heap created earlier and print elements within the range `[10, 40]`.

2. **Insert Multiple Elements into a Heap:**

   - **Problem:** Write a function to insert multiple elements into a max-heap or a min-heap. Insert the values `[35, 25, 15]` into the heap created earlier and maintain the heap property.

3. **Find the LCA (Lowest Common Ancestor) of Two Nodes in a Binary Heap:**

   - **Problem:** Write a function to find the lowest common ancestor (LCA) of two nodes in a binary heap. Use the heap created earlier to find the LCA of nodes `50` and `70`.

4. **Implement Heapsort for Ascending Order using a Min-Heap:**

   - **Problem:** Write a program to implement the heapsort algorithm to sort an array in **ascending order** using a **min-heap**. Use the array `[70, 50, 60, 40, 30, 20, 10]` and sort it in ascending order using the heapsort algorithm.
   - **Approach:** The min-heap guarantees that the minimum element is always at the root. You can repeatedly extract the minimum element from the min-heap and store it in the sorted array to achieve ascending order.

5. **Implement Heapsort for Descending Order using a Max-Heap:**

   - **Problem:** Write a program to implement the heapsort algorithm to sort an array in **descending order** using a **max-heap**. Use the array `[10, 20, 30, 40, 50, 60, 70]` and sort it in descending order using the heapsort algorithm.
   - **Approach:** The max-heap guarantees that the maximum element is always at the root. You can repeatedly extract the maximum element from the max-heap and store it in the sorted array to achieve descending order.

<!-- Segment Tree -->

## 14. Segment Tree

1. **Basic Segment Tree Creation:**

   - **Problem:** Write a program to create a segment tree for the following array: `[1, 3, 5, 7, 9, 11]`. Each node of the tree should store the sum of a range of elements from the array.

2. **Range Sum Query in a Segment Tree:**

   - **Problem:** Write a function to find the sum of elements within a given range in a segment tree. Use the segment tree created in the previous problem and find the sum of elements between index `1` and `4`.

3. **Update an Element in a Segment Tree:**

   - **Problem:** Write a function to update an element in the segment tree. Change the value at index `3` to `6` in the array `[1, 3, 5, 7, 9, 11]` and update the segment tree accordingly.

4. **Range Minimum Query (RMQ) in a Segment Tree:**

   - **Problem:** Write a function to find the minimum element in a given range using a segment tree. Use the segment tree created earlier and find the minimum element between index `1` and `4`.

5. **Range Maximum Query (RMQ) in a Segment Tree:**

   - **Problem:** Write a function to find the maximum element in a given range using a segment tree. Use the segment tree created earlier and find the maximum element between index `1` and `4`.

6. **Range GCD Query in a Segment Tree:**

   - **Problem:** Write a function to find the GCD (Greatest Common Divisor) of elements within a given range in a segment tree. Use the array `[2, 4, 6, 8, 16]` and find the GCD of the elements between index `1` and `3`.

7. **Range Product Query in a Segment Tree:**

   - **Problem:** Write a function to calculate the product of elements in a given range using a segment tree. Use the array `[1, 2, 3, 4, 5, 6]` and find the product of elements between index `2` and `5`.

8. **Lazy Propagation for Range Updates in a Segment Tree:**

   - **Problem:** Write a function to implement lazy propagation for range updates in a segment tree. Update the range `[2, 4]` by adding `3` to each element in the array `[1, 3, 5, 7, 9, 11]` and update the segment tree accordingly.

9. **Range Sum with Lazy Propagation in a Segment Tree:**

   - **Problem:** Write a function to find the sum of elements in a given range using lazy propagation in a segment tree. Use the segment tree from the previous problem and find the sum of elements between index `1` and `5`.

10. **Point Update in a Segment Tree:**

    - **Problem:** Write a function to perform a point update (change a single element) in a segment tree. Change the value at index `2` to `10` in the array `[1, 3, 5, 7, 9, 11]` and update the segment tree accordingly.

11. **Range XOR Query in a Segment Tree:**

    - **Problem:** Write a function to find the XOR of elements in a given range using a segment tree. Use the array `[1, 2, 3, 4, 5, 6]` and find the XOR of elements between index `1` and `4`.

12. **Range Sum with Point Update in a Segment Tree:**

    - **Problem:** Write a function to calculate the sum of elements within a given range and update a specific element in a segment tree. Use the array `[1, 3, 5, 7, 9, 11]`, find the sum of elements between index `1` and `4`, and update the value at index `3` to `6`.

13. **Find the Kth Smallest Element using a Segment Tree:**

    - **Problem:** Write a function to find the k-th smallest element in a given range using a segment tree. Use the array `[5, 3, 9, 1, 7, 4]` and find the 3rd smallest element in the range `[1, 5]`.

14. **Range Median Query in a Segment Tree:**

    - **Problem:** Write a function to find the median of elements within a given range using a segment tree. Use the array `[1, 5, 9, 7, 3, 11]` and find the median of elements between index `1` and `4`.

15. **Range Maximum with Point Update in a Segment Tree:**

    - **Problem:** Write a function to calculate the maximum element in a given range and update a specific element in a segment tree. Use the array `[1, 3, 5, 7, 9, 11]`, find the maximum element between index `0` and `3`, and update the value at index `2` to `10`.

16. **Build a Segment Tree from a Given Array:**

    - **Problem:** Write a program to construct a segment tree from a given array `[8, 4, 2, 6, 3, 7]`. Each node of the tree should store the sum of a range of elements from the array.

17. **Range Sum and Range Update with Lazy Propagation:**

    - **Problem:** Write a function to find the sum of elements in a given range and perform a range update using lazy propagation in a segment tree. Use the array `[1, 3, 5, 7, 9, 11]`, update the range `[1, 3]` by adding `5` to each element, and find the sum of elements between index `1` and `5`.

18. **Range Sum of Even Numbers in a Segment Tree:**

    - **Problem:** Write a function to find the sum of even numbers in a given range using a segment tree. Use the array `[2, 4, 6, 8, 10, 12]` and find the sum of even numbers between index `1` and `4`.

19. **Range Sum of Odd Numbers in a Segment Tree:**

    - **Problem:** Write a function to find the sum of odd numbers in a given range using a segment tree. Use the array `[1, 3, 5, 7, 9, 11]` and find the sum of odd numbers between index `0` and `5`.

20. **Range Sum of Primes in a Segment Tree:**

    - **Problem:** Write a function to find the sum of prime numbers in a given range using a segment tree. Use the array `[2, 3, 4, 5, 6, 7, 8]` and find the sum of prime numbers between index `1` and `6`.

21. **Check if a Given Element Exists in a Segment Tree:**

    - **Problem:** Write a function to check if a given element exists within a specific range in a segment tree. Use the array `[10, 20, 30, 40, 50, 60]` and check if the element `30` exists between index `1` and `4`.

22. **Range Modulo Query in a Segment Tree:**

    - **Problem:** Write a function to find the modulo `m` of the sum of elements within a given range in a segment tree. Use the array `[1, 2, 3, 4, 5, 6]`, find the sum of elements between index `2` and `5`, and return the result modulo `3`.

23. **Find the Range with Maximum Sum in a Segment Tree:**

    - **Problem:** Write a function to find the range with the maximum sum in a segment tree. Use the array `[3, -2, 5, -1, 2, 6, -3]` and find the range with the maximum sum.

24. **Find the Number of Elements Greater Than a Given Value in a Range:**

    - **Problem:** Write a function to count the number of elements greater than a given value `x` in a specific range using a segment tree. Use the array `[10, 20, 30, 40, 50, 60]` and find how many elements are greater than `25` between index `1` and `5`.

25. **Find the Number of Elements Less Than a Given Value in a Range:**

    - **Problem:** Write a function to count the number of elements less than a given value `x` in a specific range using a segment tree. Use the array `[10, 20, 30, 40, 50, 60]` and find how many elements are less than `35` between index `0` and `4`.

<!-- Trie (Prefix Tree) -->

## 15. Trie (Prefix Tree)

1. **Basic Trie Insertion:**

   - **Problem:** Write a program to implement a basic Trie. Insert the following words: `["apple", "app", "bat", "ball", "cat"]` into the Trie and display the structure of the Trie.

2. **Search for a Word in a Trie:**

   - **Problem:** Write a function to search for a word in a Trie. Use the Trie created earlier and search for the words `"apple"`, `"bat"`, and `"dog"`.

3. **Prefix Search in a Trie:**

   - **Problem:** Write a function to search for all words that start with a given prefix. Use the Trie created earlier to find words that start with the prefix `"ap"` and `"ba"`.

4. **Check if a Word Exists in a Trie:**

   - **Problem:** Write a function to check if a specific word exists in the Trie. Use the Trie from previous problems and check for the existence of `"cat"`, `"bat"`, and `"cap"`.

5. **Delete a Word from a Trie:**

   - **Problem:** Write a function to delete a word from the Trie. Delete the word `"bat"` from the Trie created earlier and ensure that the Trie structure is updated correctly.

6. **Count the Number of Words in a Trie:**

   - **Problem:** Write a function to count the total number of words stored in the Trie. Use the Trie created earlier and count the total words.

7. **Find All Words Stored in a Trie:**

   - **Problem:** Write a function to find and return all words stored in a Trie. Use the Trie created earlier and print all the words stored in it.

8. **Find the Longest Word in a Trie:**

   - **Problem:** Write a function to find the longest word stored in a Trie. Use the Trie created earlier and find the longest word.

9. **Check if a Trie is Empty:**

   - **Problem:** Write a function to check if a Trie is empty (i.e., contains no words). Use the Trie from previous problems and check its state.

10. **Autocomplete Suggestions Using Trie:**

    - **Problem:** Write a function to implement autocomplete suggestions using a Trie. For a given prefix, return all words that can complete the prefix. Use the Trie created earlier and find suggestions for the prefix `"ca"`.

11. **Find Words Matching a Pattern in a Trie:**

    - **Problem:** Write a function to find all words in the Trie that match a given pattern where `.` can represent any character (similar to regular expressions). Use the Trie created earlier and find words matching the patterns `"b.ll"` and `"a.p.e"`.

12. **Find the Shortest Unique Prefix for Each Word in a Trie:**

    - **Problem:** Write a function to find the shortest unique prefix for each word in the Trie. Use the list `["dog", "dove", "duck", "dot"]` and find the unique prefixes for each word.

13. **Find the Longest Common Prefix Using Trie:**

    - **Problem:** Write a function to find the longest common prefix among a set of words using a Trie. Use the words `["apple", "appetizer", "application", "appetite"]` and find the longest common prefix.

14. **Insert Multiple Words into a Trie:**

    - **Problem:** Write a function to insert multiple words into the Trie. Insert the words `["hello", "hero", "hill", "heat"]` into the Trie and display the structure.

15. **Word Count with Prefix in a Trie:**

    - **Problem:** Write a function to count how many words in the Trie start with a given prefix. Use the Trie created earlier and count how many words start with the prefixes `"he"` and `"hi"`.

16. **Find Words with Common Prefix in a Trie:**

    - **Problem:** Write a function to find all words in the Trie that share a common prefix. Use the Trie created earlier and find all words that share the prefix `"ho"`.

17. **Build a Trie from a Dictionary:**

    - **Problem:** Write a program to build a Trie from a given dictionary of words. Use the dictionary `["apple", "app", "bat", "ball", "cat", "cap"]` and construct a Trie.

18. **Check if a Word is a Prefix of Another Word in the Trie:**

    - **Problem:** Write a function to check if a given word is a prefix of any other word stored in the Trie. Use the Trie created earlier and check if `"app"` is a prefix of any other word.

19. **Find All Words of a Specific Length in a Trie:**

    - **Problem:** Write a function to find all words of a given length stored in a Trie. Use the Trie created earlier and find all words of length 3 and 4.

20. **Case-Insensitive Search in a Trie:**

    - **Problem:** Write a function to perform case-insensitive searches in a Trie. Use the Trie created earlier and search for the words `"Apple"`, `"BaT"`, and `"CAT"` in a case-insensitive manner.

21. **Count Total Nodes in a Trie:**

    - **Problem:** Write a function to count the total number of nodes (letters) stored in a Trie. Use the Trie created earlier and count the total nodes.

22. **Check if Two Tries are Identical:**

    - **Problem:** Write a function to check if two tries are identical in structure and content. Create two Tries with the words `["dog", "cat", "bat"]` and check if they are identical.

23. **Insert a Sentence into a Trie:**

    - **Problem:** Write a function to insert a sentence into a Trie by treating each word in the sentence as a node. Insert the sentence `"the quick brown fox"` into the Trie and display its structure.

24. **Longest Word with All Prefixes in a Trie:**

    - **Problem:** Write a function to find the longest word in the Trie where every prefix of the word is also present in the Trie. Use the Trie created earlier and find such a word.

25. **Delete a Word with Lazy Deletion in a Trie:**

    - **Problem:** Write a function to implement lazy deletion in a Trie. Mark words as deleted without removing nodes. Use the Trie from previous problems and delete `"bat"` using lazy deletion.

<!-- Binary Indexed Tree (BIT) -->

## 16. Binary Indexed Tree (BIT)

1. **Basic Binary Indexed Tree Construction:**

   - **Problem:** Write a program to create a Binary Indexed Tree (BIT) for the following array: `[1, 3, 5, 7, 9, 11]`. Initialize the BIT and display the tree structure.

2. **Update an Element in a Binary Indexed Tree:**

   - **Problem:** Write a function to update an element in the Binary Indexed Tree. Change the value at index `3` to `10` in the array `[1, 3, 5, 7, 9, 11]` and update the BIT accordingly.

3. **Range Sum Query in a Binary Indexed Tree:**

   - **Problem:** Write a function to find the sum of elements between two indices in a Binary Indexed Tree. Use the BIT created earlier and find the sum of elements between index `1` and `4`.

4. **Prefix Sum Query in a Binary Indexed Tree:**

   - **Problem:** Write a function to find the prefix sum up to a given index in a Binary Indexed Tree. Use the BIT created earlier and find the prefix sum up to index `3`.

5. **Construct a Binary Indexed Tree from an Array:**

   - **Problem:** Write a program to construct a Binary Indexed Tree from the array `[5, 3, 7, 9, 6, 2, 4]`. Display the tree structure and verify the values.

6. **Range Update in a Binary Indexed Tree:**

   - **Problem:** Write a function to perform a range update in a Binary Indexed Tree. Add `3` to all elements between index `1` and `4` in the array `[2, 4, 6, 8, 10, 12]` and update the BIT accordingly.

7. **Range Minimum Query in a Binary Indexed Tree:**

   - **Problem:** Write a function to find the minimum value in a given range using a Binary Indexed Tree. Use the BIT from previous problems and find the minimum value between index `2` and `5`.

8. **Point Update in a Binary Indexed Tree:**

   - **Problem:** Write a function to perform a point update (change a single element) in a Binary Indexed Tree. Change the value at index `4` to `20` in the array `[1, 2, 3, 4, 5]` and update the BIT accordingly.

9. **Find the Kth Smallest Element Using Binary Indexed Tree:**

   - **Problem:** Write a function to find the k-th smallest element in a sorted array using a Binary Indexed Tree. Use the array `[1, 3, 4, 7, 8, 9]` and find the 4th smallest element.

10. **Range XOR Query in a Binary Indexed Tree:**

    - **Problem:** Write a function to find the XOR of elements in a given range using a Binary Indexed Tree. Use the array `[1, 2, 3, 4, 5]` and find the XOR of elements between index `1` and `3`.

11. **Range Sum with Point Update in a Binary Indexed Tree:**

    - **Problem:** Write a function to calculate the sum of elements within a given range and update a specific element in a Binary Indexed Tree. Use the array `[1, 3, 5, 7, 9]`, find the sum of elements between index `2` and `4`, and update the value at index `3` to `10`.

12. **Find the Prefix Sum for Odd Numbers in a Binary Indexed Tree:**

    - **Problem:** Write a function to calculate the prefix sum for all odd numbers in a Binary Indexed Tree. Use the array `[2, 3, 5, 6, 8, 9]` and find the sum of odd numbers up to index `5`.

13. **Find the Range Product Using Binary Indexed Tree:**

    - **Problem:** Write a function to calculate the product of elements in a given range using a Binary Indexed Tree. Use the array `[1, 2, 3, 4, 5]` and find the product of elements between index `1` and `4`.

14. **Find the Number of Elements Greater than X in a Binary Indexed Tree:**

    - **Problem:** Write a function to count the number of elements greater than a given value `x` in a specific range using a Binary Indexed Tree. Use the array `[10, 20, 30, 40, 50]` and find how many elements are greater than `25` between index `1` and `4`.

15. **Find the Number of Elements Less than X in a Binary Indexed Tree:**

    - **Problem:** Write a function to count the number of elements less than a given value `x` in a specific range using a Binary Indexed Tree. Use the array `[10, 20, 30, 40, 50]` and find how many elements are less than `35` between index `0` and `3`.

16. **Range Sum with Lazy Propagation Using Binary Indexed Tree:**

    - **Problem:** Write a function to calculate the range sum with lazy propagation in a Binary Indexed Tree. Use the array `[1, 2, 3, 4, 5]`, update the range `[2, 4]` by adding `5` to each element, and find the sum between index `1` and `4`.

17. **Find the Prefix Sum for Even Numbers in a Binary Indexed Tree:**

    - **Problem:** Write a function to calculate the prefix sum for all even numbers in a Binary Indexed Tree. Use the array `[2, 3, 4, 5, 6, 7, 8]` and find the sum of even numbers up to index `5`.

18. **Find the Longest Increasing Subsequence Using Binary Indexed Tree:**

    - **Problem:** Write a function to find the longest increasing subsequence in an array using a Binary Indexed Tree. Use the array `[3, 4, 5, 1, 2, 8, 6, 7]` and find the length of the longest increasing subsequence.

19. **Find the Kth Largest Element Using Binary Indexed Tree:**

    - **Problem:** Write a function to find the k-th largest element in an array using a Binary Indexed Tree. Use the array `[1, 3, 5, 7, 9]` and find the 3rd largest element.

20. **Count the Number of Inversions Using Binary Indexed Tree:**

    - **Problem:** Write a function to count the number of inversions in an array using a Binary Indexed Tree. An inversion is when a larger element appears before a smaller element in the array. Use the array `[8, 4, 2, 1]` and count the number of inversions.

21. **Update Multiple Elements in a Binary Indexed Tree:**

    - **Problem:** Write a function to update multiple elements in a Binary Indexed Tree. Update the elements at indices `1, 3, and 5` by adding `5` to each value in the array `[2, 4, 6, 8, 10]` and update the BIT accordingly.

22. **Find the GCD of Elements in a Range Using Binary Indexed Tree:**

    - **Problem:** Write a function to find the GCD (Greatest Common Divisor) of elements in a given range using a Binary Indexed Tree. Use the array `[12, 18, 24, 36]` and find the GCD of elements between index `1` and `3`.

23. **Find the Sum of Prime Numbers Using Binary Indexed Tree:**

    - **Problem:** Write a function to find the sum of prime numbers in a given range using a Binary Indexed Tree. Use the array `[2, 3, 4, 5, 6, 7]` and find the sum of primes between index `1` and `4`.

24. **Find the Largest Element Less than or Equal to X Using Binary Indexed Tree:**

    - **Problem:** Write a function to find the largest element that is less than or equal to `X` in a given range using a Binary Indexed Tree. Use the array `[10, 20, 30, 40, 50]` and find the largest element less than or equal to `35` between index `1` and `4`.

25. **Convert a Binary Indexed Tree to a Segment Tree:**

    - **Problem:** Write a function to convert a Binary Indexed Tree into a Segment Tree. Use the array `[1, 2, 3, 4, 5]` to build a BIT and convert it into a Segment Tree.
